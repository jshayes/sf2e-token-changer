{"version":3,"file":"module.js","sources":["../../src/ts/constants.ts","../../src/ts/tokenChanger.ts","../../src/ts/module.ts"],"sourcesContent":["import { id } from \"../module.json\";\n\nexport const moduleId = id;\n","import { moduleId } from \"./constants\";\n\nconst tokenConfigTemplate = `modules/${moduleId}/templates/token-config.hbs`;\nconst tokenImageFieldTemplate =\n  `modules/${moduleId}/templates/components/token-image-field.hbs`;\n\ntype HpPercentCondition = {\n  type: \"hp-percent\";\n  operator: \"<\" | \"<=\" | \">\" | \">=\";\n  value: number;\n};\n\ntype CombatCondition = {\n  type: \"combat\";\n  value: boolean;\n};\n\ntype StatusEffectCondition = {\n  type: \"status-effect\";\n  operator: \"any-of\" | \"all-of\";\n  value: string[];\n};\n\ntype RuleCondition = HpPercentCondition | CombatCondition | StatusEffectCondition;\n\ntype TokenUpdateEffect = {\n  type: \"token-update\";\n  value: Record<string, unknown>;\n};\n\ntype PlaySoundEffect = {\n  type: \"play-sound\";\n  src: string;\n  volume?: number;\n};\n\ntype RuleEffect = TokenUpdateEffect | PlaySoundEffect;\n\ntype TokenRule = {\n  id: string;\n  triggers: RuleCondition[];\n  effects: RuleEffect[];\n};\n\ntype ModuleTokenFlags = {\n  rules?: TokenRule[];\n  rulesJSON?: string;\n  _defaults?: {\n    ring?: unknown;\n    texture?: unknown;\n  };\n  state?: string | null;\n};\n\ntype ApplyStateSocketPayload = {\n  type: \"applyState\";\n  sceneId: string;\n  tokenIds: string[];\n};\n\ntype TokenOrPlaceable = TokenDocument | { document: TokenDocument };\n\nfunction asTokenDocument(token: TokenOrPlaceable | null | undefined): TokenDocument | undefined {\n  if (!token) return undefined;\n  if (\"document\" in token) return token.document;\n  return token;\n}\n\nfunction isApplyStateSocketPayload(value: unknown): value is ApplyStateSocketPayload {\n  const payload = value as Partial<ApplyStateSocketPayload> | null | undefined;\n  return (\n    payload?.type === \"applyState\" &&\n    typeof payload.sceneId === \"string\" &&\n    Array.isArray(payload.tokenIds)\n  );\n}\n\nasync function loadModuleTemplates(paths: string[]): Promise<void> {\n  const loader = (globalThis as { loadTemplates?: (templates: string[]) => Promise<unknown> }).loadTemplates;\n  if (!loader) return;\n  await loader(paths);\n}\n\nfunction addTokenStatesTab(sheetClass: {\n  TABS?: { sheet?: { tabs?: Array<Record<string, unknown>> } };\n  PARTS?: Record<string, unknown>;\n}): void {\n  sheetClass.TABS?.sheet?.tabs?.push({\n    id: moduleId,\n    label: \"Token States\",\n    icon: \"fa-solid fa-grid\",\n  });\n\n  if (!sheetClass.PARTS) return;\n\n  const footer = sheetClass.PARTS.footer;\n  delete sheetClass.PARTS.footer;\n\n  sheetClass.PARTS[moduleId] = {\n    template: tokenConfigTemplate,\n    scrollable: [\"\"],\n  };\n\n  sheetClass.PARTS.footer = footer;\n}\n\nfunction validateRulesJSON(json: unknown): TokenRule[] | null | undefined {\n  if (json === undefined) return undefined;\n  if (json === \"\") return null;\n\n  const parsed = JSON.parse(String(json));\n  if (!Array.isArray(parsed)) {\n    throw new Error(\"Rules must be an array\");\n  }\n\n  return parsed as TokenRule[];\n}\n\nfunction getModuleFlags(token: TokenDocument): ModuleTokenFlags {\n  return ((token.flags as Record<string, unknown>)[moduleId] ?? {}) as ModuleTokenFlags;\n}\n\nfunction checkHpPercentCondition(condition: HpPercentCondition, token: TokenDocument): boolean {\n  const actor = token.actor as\n    | {\n        system?: {\n          attributes?: {\n            hp?: { value?: number; max?: number };\n          };\n        };\n      }\n    | null\n    | undefined;\n\n  const hp = actor?.system?.attributes?.hp;\n  const value = hp?.value ?? 0;\n  const max = hp?.max ?? 0;\n  const hpPerc = max > 0 ? value / max : 0;\n\n  switch (condition.operator) {\n    case \"<\":\n      return hpPerc < condition.value;\n    case \"<=\":\n      return hpPerc <= condition.value;\n    case \">\":\n      return hpPerc > condition.value;\n    case \">=\":\n      return hpPerc >= condition.value;\n    default:\n      return false;\n  }\n}\n\nfunction checkCombatCondition(condition: CombatCondition, token: TokenDocument): boolean {\n  return Boolean((token as TokenDocument & { inCombat?: boolean }).inCombat) === condition.value;\n}\n\nfunction checkStatusEffectCondition(\n  condition: StatusEffectCondition,\n  token: TokenDocument,\n): boolean {\n  const actor = token.actor as\n    | {\n        conditions?: {\n          active?: Array<{ slug?: string }>;\n        };\n      }\n    | null\n    | undefined;\n\n  const matchedConditions = (actor?.conditions?.active ?? []).filter((entry) =>\n    condition.value.includes(String(entry.slug ?? \"\")),\n  );\n\n  switch (condition.operator) {\n    case \"any-of\":\n      return matchedConditions.length > 0;\n    case \"all-of\":\n      return matchedConditions.length === condition.value.length;\n    default:\n      return false;\n  }\n}\n\nfunction checkRule(rule: TokenRule, token: TokenDocument): boolean {\n  for (const condition of rule.triggers ?? []) {\n    switch (condition.type) {\n      case \"hp-percent\":\n        if (!checkHpPercentCondition(condition, token)) return false;\n        break;\n      case \"combat\":\n        if (!checkCombatCondition(condition, token)) return false;\n        break;\n      case \"status-effect\":\n        if (!checkStatusEffectCondition(condition, token)) return false;\n        break;\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction findHighestPriorityRule(token: TokenDocument): TokenRule | undefined {\n  const rules = getModuleFlags(token).rules;\n  return rules?.find((rule) => checkRule(rule, token));\n}\n\nfunction getActions(tokens: TokenDocument[]): {\n  tokenUpdates: Record<string, Record<string, unknown>[]>;\n  soundsToPlay: Array<{ src: string; volume?: number; loop: boolean }>;\n} {\n  const tokenUpdates: Record<string, Record<string, Record<string, unknown>>> = {};\n  const soundsToPlay: Array<{ src: string; volume?: number; loop: boolean }> = [];\n\n  const queueTokenUpdate = (token: TokenDocument, update: Record<string, unknown>) => {\n    const sceneId = String(token.parent?.id ?? \"\");\n    if (!sceneId) return;\n\n    const sceneUpdates = (tokenUpdates[sceneId] ??= {});\n    const tokenId = String(token.id);\n    const existing = (sceneUpdates[tokenId] ??= { _id: tokenId });\n    foundry.utils.mergeObject(existing, update, { inplace: true });\n  };\n\n  for (const token of tokens) {\n    const flags = getModuleFlags(token);\n    if (!flags.rules) continue;\n\n    const rule = findHighestPriorityRule(token);\n    if (!rule) {\n      if (flags._defaults) {\n        queueTokenUpdate(token, {\n          ...flags._defaults,\n          [`flags.${moduleId}.-=_defaults`]: null,\n        });\n      }\n      queueTokenUpdate(token, { [`flags.${moduleId}.state`]: null });\n      continue;\n    }\n\n    const tokenUpdate: Record<string, unknown> = {};\n    if (!flags._defaults) {\n      tokenUpdate[`flags.${moduleId}._defaults`] = {\n        ring: token.ring,\n        texture: token.texture,\n      };\n    }\n\n    const shouldSkipSound = flags.state === rule.id;\n    tokenUpdate[`flags.${moduleId}.state`] = rule.id;\n    let queuedTokenUpdate = false;\n\n    for (const effect of rule.effects ?? []) {\n      switch (effect.type) {\n        case \"token-update\": {\n          const currentRingTexture =\n            (token.ring as { subject?: { texture?: unknown } } | undefined)?.subject\n              ?.texture;\n          const nextRingTexture =\n            (effect.value.ring as { subject?: { texture?: unknown } } | undefined)\n              ?.subject?.texture;\n\n          if (currentRingTexture !== nextRingTexture) {\n            queueTokenUpdate(token, { ...tokenUpdate, ...effect.value });\n            queuedTokenUpdate = true;\n          }\n          break;\n        }\n        case \"play-sound\": {\n          if (!shouldSkipSound) {\n            soundsToPlay.push({\n              src: effect.src,\n              volume: effect.volume,\n              loop: false,\n            });\n          }\n          break;\n        }\n      }\n    }\n\n    if (!queuedTokenUpdate) {\n      queueTokenUpdate(token, tokenUpdate);\n    }\n  }\n\n  const updatesByScene = Object.fromEntries(\n    Object.entries(tokenUpdates).map(([sceneId, updates]) => [\n      sceneId,\n      Object.values(updates),\n    ]),\n  );\n\n  return {\n    tokenUpdates: updatesByScene,\n    soundsToPlay,\n  };\n}\n\nasync function handleTokenEvents(\n  tokens: Array<TokenDocument | null | undefined>,\n  skipSound = false,\n): Promise<void> {\n  const cleanTokens = tokens.filter((token): token is TokenDocument => Boolean(token));\n\n  if (!game.user.isGM) {\n    if (canvas.scene) {\n      const tokenIds = cleanTokens\n        .filter((token) => Boolean(canvas.tokens.get(token.id)))\n        .map((token) => token.id);\n\n      game.socket.emit(`module.${moduleId}`, {\n        type: \"applyState\",\n        sceneId: canvas.scene.id,\n        tokenIds,\n      } satisfies ApplyStateSocketPayload);\n    }\n    return;\n  }\n\n  const { tokenUpdates, soundsToPlay } = getActions(cleanTokens);\n\n  for (const [sceneId, updates] of Object.entries(tokenUpdates)) {\n    const scene = game.scenes.get(sceneId);\n    if (!scene) continue;\n    await scene.updateEmbeddedDocuments(\n      \"Token\",\n      updates as Array<{ _id: string } & Record<string, unknown>>,\n    );\n  }\n\n  if (!skipSound) {\n    for (const sound of soundsToPlay) {\n      foundry.audio.AudioHelper.play(\n        sound,\n        { broadcast: true } as unknown as { recipients: string[] },\n      );\n    }\n  }\n}\n\nfunction handleTokenEvent(token: TokenDocument): void {\n  void handleTokenEvents([token]);\n}\n\nfunction handleActorEvent(actor: Actor): void {\n  const docs = actor\n    .getActiveTokens()\n    .map((token) => asTokenDocument(token))\n    .filter((token): token is TokenDocument => Boolean(token));\n\n  void handleTokenEvents(docs);\n}\n\nfunction handleCombatantEvents(combatants: Combatant[]): void {\n  const docs = combatants\n    .map((combatant) => asTokenDocument(combatant.token as TokenOrPlaceable | null))\n    .filter((token): token is TokenDocument => Boolean(token));\n\n  void handleTokenEvents(docs);\n}\n\nfunction handleCombatantEvent(combatant: Combatant): void {\n  handleCombatantEvents([combatant]);\n}\n\nfunction handleCombatEvent(encounter: Combat): void {\n  handleCombatantEvents(Array.from(encounter.combatants));\n}\n\nfunction handleCanvasEvent(currentCanvas: {\n  tokens: { placeables: Array<{ document: TokenDocument }> };\n}): void {\n  const docs = currentCanvas.tokens.placeables.map((token) => token.document);\n  void handleTokenEvents(docs, true);\n}\n\nexport function registerTokenChangerHooks(): void {\n  Hooks.on(\"ready\", async () => {\n    if (!game.user.isGM) return;\n\n    await loadModuleTemplates([tokenImageFieldTemplate]);\n\n    addTokenStatesTab(\n      foundry.applications.sheets.TokenConfig as unknown as {\n        TABS?: { sheet?: { tabs?: Array<Record<string, unknown>> } };\n        PARTS?: Record<string, unknown>;\n      },\n    );\n    addTokenStatesTab(\n      foundry.applications.sheets.PrototypeTokenConfig as unknown as {\n        TABS?: { sheet?: { tabs?: Array<Record<string, unknown>> } };\n        PARTS?: Record<string, unknown>;\n      },\n    );\n  });\n\n  Hooks.once(\"ready\", () => {\n    if (!game.user.isGM) return;\n\n    game.socket.on(`module.${moduleId}`, async (data: unknown) => {\n      if (!isApplyStateSocketPayload(data)) return;\n      const scene = game.scenes.get(data.sceneId);\n      if (!scene) return;\n\n      const tokens = data.tokenIds.map((id) => scene.tokens.get(id));\n      await handleTokenEvents(tokens, true);\n    });\n  });\n\n  Hooks.on(\"preUpdateActor\", (_actor, changes) => {\n    const draft = changes as {\n      prototypeToken?: {\n        flags?: Record<string, { rulesJSON?: unknown; rules?: TokenRule[] | null }>;\n      };\n    };\n\n    const raw = draft.prototypeToken?.flags?.[moduleId]?.rulesJSON;\n    if (raw === undefined) return;\n\n    try {\n      const rules = validateRulesJSON(raw);\n      if (!draft.prototypeToken?.flags?.[moduleId]) return;\n      draft.prototypeToken.flags[moduleId].rules = rules;\n    } catch (error) {\n      ui.notifications.error(`Invalid rules JSON: ${(error as Error).message}`);\n    }\n  });\n\n  Hooks.on(\"preUpdateToken\", (_doc, changes) => {\n    const draft = changes as {\n      flags?: Record<string, { rulesJSON?: unknown; rules?: TokenRule[] | null }>;\n    };\n\n    const raw = draft.flags?.[moduleId]?.rulesJSON;\n    if (raw === undefined) return;\n\n    try {\n      const rules = validateRulesJSON(raw);\n      if (!draft.flags?.[moduleId]) return;\n      draft.flags[moduleId].rules = rules;\n    } catch (error) {\n      ui.notifications.error(`Invalid rules JSON: ${(error as Error).message}`);\n    }\n  });\n\n  Hooks.on(\"createCombat\", handleCombatEvent);\n  Hooks.on(\"updateCombat\", handleCombatEvent);\n  Hooks.on(\"deleteCombat\", handleCombatEvent);\n\n  Hooks.on(\"createCombatant\", handleCombatantEvent);\n  Hooks.on(\"updateCombatant\", handleCombatantEvent);\n  Hooks.on(\"deleteCombatant\", handleCombatantEvent);\n\n  Hooks.on(\"updateActor\", handleActorEvent);\n\n  Hooks.on(\"createToken\", handleTokenEvent);\n\n  Hooks.on(\"canvasReady\", handleCanvasEvent);\n  Hooks.on(\"applyTokenStatusEffect\", (token) => {\n    const doc = asTokenDocument(token as TokenOrPlaceable);\n    if (doc) handleTokenEvent(doc);\n  });\n}\n","// Do not remove this import. If you do Vite will think your styles are dead\n// code and not include them in the build output.\nimport \"../styles/style.scss\";\nimport { registerTokenChangerHooks } from \"./tokenChanger\";\n\nHooks.once(\"init\", () => {\n  registerTokenChangerHooks();\n});\n\nif (import.meta.hot) {\n  import.meta.hot.accept();\n}\n"],"names":["moduleId","id","tokenConfigTemplate","tokenImageFieldTemplate","asTokenDocument","token","isApplyStateSocketPayload","value","payload","loadModuleTemplates","paths","loader","addTokenStatesTab","sheetClass","footer","validateRulesJSON","json","parsed","getModuleFlags","checkHpPercentCondition","condition","hp","max","hpPerc","checkCombatCondition","checkStatusEffectCondition","matchedConditions","entry","checkRule","rule","findHighestPriorityRule","getActions","tokens","tokenUpdates","soundsToPlay","queueTokenUpdate","update","sceneId","sceneUpdates","tokenId","existing","flags","tokenUpdate","shouldSkipSound","queuedTokenUpdate","effect","currentRingTexture","nextRingTexture","updates","handleTokenEvents","skipSound","cleanTokens","tokenIds","scene","sound","handleTokenEvent","handleActorEvent","actor","docs","handleCombatantEvents","combatants","combatant","handleCombatantEvent","handleCombatEvent","encounter","handleCanvasEvent","currentCanvas","registerTokenChangerHooks","data","_actor","changes","draft","raw","rules","error","_doc","doc"],"mappings":"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"}